Общая архитектура: двухсторонний сервис
Система представляет собой закрытый контейнеризированный ML-сервис, реализующий две основные функции:
1. Прямая задача: Принимает изображение диаграммы -> возвращает структурированное текстовое описание её логики.
2. Обратная задача: Принимает текстовое описание алгоритма -> генерирует изображение диаграммы и/или её код (BPMN/PlantUML).
Основные компоненты системы:
● API Gateway (FastAPI) - единая точка входа для обоих направлений.
● Предобработчик (Preprocessor) - нормализация входных данных (изображений/текста).
● ML Pipeline (Прямая задача):
Двухуровневая детекция: Pre-trained YOLOv8 (для общих объектов) + Auto-labeling через Vision-Language Model (например, GPT-4 Vision или Qwen-VL) для создания синтетического датасета. 
OCR-модуль (PaddleOCR) - распознаёт текст внутри элементов.
○ Построитель графа (Graph Constructor) - формирует граф связей на основе координат и правил.
○ Семантический интерпретатор (Semantic Interpreter) - определяет типы элементов и логику.
○ Генеративный Pipeline (Обратная задача):
○ Текст-в-структуру (Text-to-Graph Parser) - извлекает сущности и связи из текстового описания (на основе правил или легкой языковой модели).
○ Визуализатор (Visualizer) - рендерит граф в изображение диаграммы (используя библиотеку graphviz, diagrams, или генерирует код для draw.io).
● Постобработчик (Postprocessor) - форматирует выходные данные (JSON, изображение, код диаграммы).
● Движок шаблонов (Template Engine, Jinja2) - генерирует человекочитаемые текстовые описания по структурированному графу.
Поток данных:
1. Вход (прямая задача): Изображение (PNG/JPEG) в формате multipart/form-data или base64.
2. Обработка (прямая задача):
○ Препроцессинг изображения (OpenCV).
○ Параллельный запуск YOLO (детекция) и OCR (распознавание текста).
○ Построение графа элементов на основе координат.
○ Семантический анализ графа и генерация структурированного JSON-представления.
○ Применение шаблонов для создания текстового описания.
3. Вход (обратная задача): Текстовое описание алгоритма на русском/английском в JSON-запросе.
4. Обработка (обратная задача):
○ Парсинг текста: извлечение названий шагов, условий, связей.
○ Преобразование в промежуточный графовый формат (узлы/рёбра).
○ Рендеринг графа в изображение (через graphviz) и/или генерация кода диаграммы (PlantUML, Mermaid).
5. Выход (для обеих задач): Единый JSON-формат, содержащий:
6. json
7. {
8.   "task_type": "image_to_text" | "text_to_diagram",
9.   "description": "Текстовое описание алгоритма...",
10.   "graph_representation": { "nodes": [...], "edges": [...] },
11.   "artifacts": {
12.     "diagram_image_base64": "...", // Для обратной задачи
13.     "diagram_code": "plantuml code..." // Опционально
14.   },
15.   "processing_time_sec": 5.2
16. }
Использование ML/LLM:
● YOLOv8n (дообученная) - для детекции элементов диаграмм в прямой задаче.
● PaddleOCR (готовая) - для распознавания текста в прямой задаче.
● Языковая модель (легкая, например, bert-base-multilingual-cased или ruBERT-tiny) - опционально, для обратной задачи, для улучшения парсинга сложных текстовых описаний. Первая версия будет использовать rule-based парсер.
Развёртывание:
● Сервис упакован в единый Docker-контейнер.
● Поддерживает работу как на CPU, так и на GPU (требование: ≤8 ГБ VRAM).
● Для запуска: docker run -p 8000:8000 diagram-service.
● Конфигурация запуска (режим CPU/GPU) задаётся через переменные окружения.
2. Технологический стек


Компонент
Выбор
Обоснование
Язык программирования
Python 3.10
Стандарт для ML-разработки, богатая экосистема библиотек для CV, NLP и генерации графики.
Backend / API Framework
FastAPI
Высокая производительность, автоматическая 
генерация OpenAPI-документации (Swagger), асинхронная поддержка. Идеален для ML-сервисов.
ML / CV библиотеки
Ultralytics (YOLOv8), OpenCV, PaddleOCR
YOLOv8 - лучший баланс скорости/точности для детекции; OpenCV - стандарт для препроцессинга; PaddleOCR - поддержка RU/EN без дообучения, 
работает на CPU.
NLP / Текстовая обработка
spaCy, Natasha (для ru), Jinja2, NetworkX
spaCy/Natasha - для извлечения сущностей и синтаксического разбора в обратной задаче. Jinja2 - 
для шаблонной генерации текстовых описаний в 
прямой задаче.
NetworkX применяется для построения и строгой 
математической валидации графа алгоритма. 
Генерация диаграмм (обратная задача)
Graphviz (pygraphviz), diagrams, PlantUML
Graphviz - надежная, детерминированная визуализация графов. diagrams - генерация диаграмм 
инфраструктуры как кода. PlantUML - стандарт для текстового описания UML/BPMN.
Формат взаимодействия
REST / JSON
Стандарт для веб-сервисов, легко интегрируется с любым клиентом (Frontend, мобильное приложение, другие сервисы).
Управление зависимостями
Poetry
Создание предсказуемых виртуальных окружений, простое управление версиями, генерация requirements.txt для Docker.
Контейнеризация
Docker, Docker Compose
Гарантирует воспроизводимость среды, изоляцию зависимостей, простоту развертывания и масштабирования.
Аппаратная платформа
Поддержка CPU и GPU (NVIDIA, ≥8 ГБ VRAM)
Соответствует требованиям заказчика. YOLOv8n укладывается в 5-6 ГБ VRAM, остальное - запас для одновремгенной работы других компонентов.
UI (опционально)
Streamlit
Позволяет быстро создать интерактивный веб-интерфейс для демонстрации обеих функций сервиса (загрузка изображения / ввод текста).
Логирование
loguru
Простой вывод структурированных логов в формате JSON, удобный для последующего анализа и сбора в системы мониторинга.
Базы данных / Очереди
Не используются на первом этапе
Система stateless. Кэширование результатов 
(например, в Redis) и очереди задач (Celery) - это опция для highload.

3. План реализации (roadmap)


Этап
Результат
1. Анализ задачи и данных (день 1)
Чёткое ТЗ: форматы ввода/вывода, метрики успеха. 
Собрана и проанализирована пилотная выборка из 
30-50 диаграмм разного типа (BPMN, блок-схемы).
2. Прототип прямой задачи (день 2, 3)
2.1. Разметка данных: Auto-labeling, используется 
мощная VLM (например, GPT-4o API или Qwen-VL) для автоматической генерации разметки 
на 100+ изображениях. 
2.2. Детекция: YOLOv8n дообучена на размеченных 
данных, получены первые bbox'ы.
2.3. OCR+Граф: Реализован пайплайн: изображение -> YOLO + PaddleOCR ->  реализуется построение графа с 
использованием NetworkX.
3. Прототип обратной задачи (день 4)
3.1. Парсинг текста: Написаны правила (регулярные выражения + spaCy) для извлечения шагов и условий
 из текстовых описаний.
3.2. Генерация графа: Реализовано преобразование распарсенного текста в графовую структуру 
(узлы/рёбра).
3.3. Визуализация: Граф рендерится в изображение через graphviz.
4. Интеграция и API (день 5)
4.1. Единый сервис: Оба пайплайна интегрированы в один FastAPI-сервис с эндпоинтами /analyze (прямая) и /generate (обратная).
4.2. Структурированный вывод: API возвращает унифицированный JSON с текстовым описанием, 
графом и дополнительными артефактами.
5. Контейнеризация и документация
5.1. Docker: Создан Dockerfile и docker-compose.yml 
для запуска всего сервиса одной командой.
5.2. Документация: Написан README.md с 
инструкцией по запуску, описанием API и 
примерами запросов.
6. Улучшения и полировка (После чекпоинта)
6.1. UI: Добавлен простой Streamlit-интерфейс.
6.2. Качество: Улучшение правил для графа, 
добавление поддержки циклов.
6.3. Производительность: Кэширование, 
оптимизация размеров изображений.
6.4. Расширение форматов: Генерация кода
 PlantUML/BPMN в обратной задаче.
